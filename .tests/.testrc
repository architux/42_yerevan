alias cc42="cc -Wall -Wextra -Werror"

function ebash() {
	bash $1 | cat -e
}

function mainc_del() {
	COLOR_GREEN="\033[32m"
	COLOR_YELLOW="\033[33m"
	COLOR_RED="\033[31m"
	COLOR_BRIGHT_RED="\033[1;31m"
	COLOR_RESET="\033[0m"

	if [ "$#" -ne 2 ]; then
		echo "Usage: $0 <SRC_DIR> <DST_DIR>"
		return 1
	fi

	SRC_DIR="$1"
	DST_DIR="$2"
	FILENAME="main.c"

	find "$SRC_DIR" -mindepth 1 -maxdepth 1 -type d -name "ex*" -print0 | while IFS= read -r -d $'\0' subdir; do
		REL_PATH="${subdir#$SRC_DIR/}"
		SOURCE_FILE_PATH="$subdir/$FILENAME"
		DEST_SUBDIR_PATH="$DST_DIR/$REL_PATH"

		if [ -f "$DEST_SUBDIR_PATH/${FILENAME}" ]; then
			rm "$DEST_SUBDIR_PATH/${FILENAME}"
			echo -e "${SRC_DIR}/${REL_PATH} => ${COLOR_YELLOW}${FILENAME}${COLOR_RESET} ${COLOR_RED}[x] ${DEST_SUBDIR_PATH}/${FILENAME}${COLOR_RESET}"
		fi
	done
}

function mainc_sync() {
	COLOR_GREEN="\033[32m"
	COLOR_YELLOW="\033[33m"
	COLOR_RED="\033[31m"
	COLOR_BRIGHT_RED="\033[1;31m"
	COLOR_RESET="\033[0m"

	if [ "$#" -ne 2 ]; then
		echo "Usage: $0 <SRC_DIR> <DST_DIR>"
		return 1
	fi

	SRC_DIR="$1"
	DST_DIR="$2"
	FILENAME="main.c"

	find "$SRC_DIR" -mindepth 1 -maxdepth 1 -type d -name "ex*" -print0 | while IFS= read -r -d $'\0' subdir; do
		REL_PATH="${subdir#$SRC_DIR/}"
		SOURCE_FILE_PATH="$subdir/$FILENAME"
		DEST_SUBDIR_PATH="$DST_DIR/$REL_PATH"

		if [ -f "$SOURCE_FILE_PATH" ]; then
			mkdir -p "$DEST_SUBDIR_PATH"

			cp "$SOURCE_FILE_PATH" "$DEST_SUBDIR_PATH/"
			echo -e "$SRC_DIR/$REL_PATH => ${COLOR_YELLOW}$FILENAME${COLOR_RESET} ${COLOR_GREEN}=> $DEST_SUBDIR_PATH${COLOR_RESET}"
		fi
	done
}

# function mainc_sync() {
# 	if [ "$#" -ne 2 ]; then
# 		echo "Usage: $0 <SRC_DIR> <DST_DIR>"
# 		return 1
# 	fi

# 	SRC_DIR="$1"
# 	DST_DIR="$2"
# 	FILENAME="main.c"

# 	TO_FORCE_COPY=""

# 	find "$SRC_DIR" -type d -print0 | while IFS= read -r -d $'\0' subdir; do
# 	# find "$SRC_DIR" -type f -name "$FILENAME" -exec dirname {} \; | sort -u | while read -r subdir; do
# 		REL_PATH="${subdir#$SRC_DIR/}"
# 		SRC_FILE_PATH="$subdir/$FILENAME"
# 		DST_SUBDIR_PATH="$DST_DIR/$REL_PATH"

# 		echo "SRC_FILE_PATH: $SRC_FILE_PATH"
# 		if [ -f "$SRC_FILE_PATH" ]; then
# 			mkdir -p "$DST_SUBDIR_PATH"

# 			if [ -f "$DST_SUBDIR_PATH/$FILENAME" && -z$TO_FORCE_COPY ]; then
# 				read -p "Files already exist, do you want to overwrite? (y/n)" user_input
# 				TO_FORCE_COPY=$user_input

# 				case "$TO_FORCE_COPY" in
# 					[y])
# 						TO_FORCE_COPY="y"
# 						;;
# 					[n])
# 						return 1
# 						;;
# 					*)
# 						echo "Invalid input, please enter 'y' or 'n'"
# 						return 1
# 						;;
# 				esac
# 			else
# 				TO_FORCE_COPY="y"
# 			fi

# 			if [ $TO_FORCE_COPY -eq "y" ]; then
# 				cp "$SRC_FILE_PATH" "$DST_SUBDIR_PATH/"
# 				echo "$SRC_DIR/$REL_PATH => $FILENAME => $DST_DIR/$REL_PATH"
# 			fi
# 		else
# 			echo "No similar subdirectories structure to sync into"
# 			return 1
# 		fi
# 	done
# }

# Run norminette with proper block-based ordering and output colorization
function norm_older() {
	norminette -R CheckForbiddenSourceHeader | gawk '
	BEGIN {
		GREEN = "\033[32m"
		YELLOW="\033[33m"
		RED = "\033[31m"
		BRIGHT_RED = "\033[1;31m"
		RESET = "\033[0m"
	}
	/: OK!$/ {
		if (header != "") {
			blocks[header] = block;
		}
		header = $0;
		block = GREEN $0 RESET "\n";
		next;
	}
	/: Error!$/ {
		if (header != "") {
			blocks[header] = block;
		}
		header = $0;
		block = RED $0 RESET "\n";
		next;
	}
	/^Notice: / {
		block = block YELLOW $0 RESET "\n";
		next;
	}
	/^Error: / {
		block = block BRIGHT_RED $0 RESET "\n";
		next;
	}
	END {
		if (header != "") {
			blocks[header] = block;
		}
		PROCINFO["sorted_in"] = "@ind_str_asc";
		for (h in blocks) {
			printf "%s", blocks[h];
		}
	}
'
}

# Run norminette with output colorization
function norm() {
	norminette -R CheckForbiddenSourceHeader | awk '
	BEGIN {
		GREEN = "\033[32m"
		YELLOW="\033[33m"
		RED = "\033[31m"
		BRIGHT_RED = "\033[1;31m"
		RESET = "\033[0m"
	}
	/^Setting locale to/ {
		next;
	}
	/: OK!$/ {
		print GREEN $0 RESET;
		next;
	}
	/: Error!$/ {
		print BRIGHT_RED $0 RESET;
		next;
	}
	match($0, /^Notice: [A-Z_]+/) {
		printf "%s", substr($0, 1, RSTART - 1);
		printf "%s%s%s", YELLOW, substr($0, RSTART, RLENGTH), RESET;
		printf "%s\n", substr($0, RSTART + RLENGTH);
		next;
	}
	match($0, /^Error: [A-Z_]+/) {
		printf "%s", substr($0, 1, RSTART - 1);
		printf "%s%s%s", RED, substr($0, RSTART, RLENGTH), RESET;
		printf "%s\n", substr($0, RSTART + RLENGTH);
		next;
	}
	{
		print $0
	}
'
}

# Batch running of norminette checking, compilation and execution of file just being compiled
function test42c() {
	shell_name="$(basename $(readlink /proc/$$/exe))"

	YELLOW="\033[33m"
	RESET="\033[0m"

	# Colorized norminette output
	norm

	# Horizontal line
	printf '%.s─' $(seq 1 $(tput cols))

	# Compilation...
	SOURCE_FILES=("$@")

	if [ ${#SOURCE_FILES[@]} -eq 0 ]; then
		case $shell_name in
			"bash")
				readarray -d '' SOURCE_FILES < <(find . -name "*.c" -printf "%P " | sed 's/ $//') ;;
			"zsh")
				SOURCE_FILES=( $(find . -name "*.c" -printf "%P " | sed 's/ $//') )
		esac
	fi

	comp_command="cc42 "${SOURCE_FILES[@]}" -o a.out"
	eval "${comp_command}"
	comp_exit_code=$?

	if [ ${comp_exit_code} -eq 0 ]; then
		# Compilation output
		echo -e "${YELLOW}${SOURCE_FILES[@]} > a.out${RESET}"

		# Horizontal line
		printf '%.s─' $(seq 1 $(tput cols))

		# Test output
		./a.out
	fi

	return ${comp_exit_code};
}
